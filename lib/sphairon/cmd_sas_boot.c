// SPDX-License-Identifier: GPL-2.0+
/*
 * Copyright (C) 2011-2020 Sphairon GmbH (a ZyXEL company)
 */

#include <common.h>
#include <command.h>
#include <malloc.h>
#include <linux/string.h>
#include <linux/mtd/mtd.h>
#include <generated/timestamp_autogenerated.h>
#include <generated/version_autogenerated.h>

#include <sas/util.h>
#include <sas/boot.h>
#include <sas/flash.h>
#include <sas/flashlayout.h>
#include <sas/etl.h>

static inline const char *sas_uboot_name(void)
{
#if defined(CONFIG_BOARD_NAME)
	return CONFIG_BOARD_NAME;
#else
	return "generic";
#endif
}

enum sas_image_src_type {
	SAS_FLASH,
	SAS_TFTP,
	SAS_NFS,
	SAS_NONE,
	SAS_PTEST,
	SAS_INVALID,
};

static const char sas_image_src_strings[][10] = {
	"flash",
	"tftp",
	"nfs",
	"none",
	"ptest",
	"invalid"
};

static const char * sas_image_src_str(enum sas_image_src_type image)
{
	assert(image <= SAS_INVALID);

	return sas_image_src_strings[image];
}

static int sas_image_src_set(const char *name, enum sas_image_src_type image,
				int *saveenv)
{
	assert(image <= SAS_INVALID);

	return sas_setenv(name, sas_image_src_strings[image], saveenv);
}

static enum sas_image_src_type
sas_parse_image_src(const char *image, enum sas_image_src_type def_image)
{
	int i, ret;

	if (!image)
		return def_image;

	for (i = 0; i < ARRAY_SIZE(sas_image_src_strings); i++) {
		ret = strcmp(image, sas_image_src_str(i));
		if (!ret)
			return i;
	}

	printf("sas_boot: invalid image src: %s\n",
		image ? image : "");

	return SAS_INVALID;
}

static const char *sas_image_str(enum sas_image_type type)
{
	switch (type) {
	case SAS_IMG_ROOTFS:
		return "rootfs";
	case SAS_IMG_SERVICEFS:
		return "servicefs";
	case SAS_IMG_DEFCONFIG:
		return "defconfig";
	default:
		return NULL;
	}
}

static int sas_kernel_load(enum sas_flash_layout_type layout, int active_image,
				enum sas_image_src_type src, ulong loadaddr)
{
	int ret = 1;
	size_t size;
	const struct sas_flash_partition *part;
	enum sas_ubi_volume_type vol_type;

	switch (src) {
	case SAS_TFTP:
		size = sas_run_tftpboot(loadaddr, SAS_KERNEL_IMAGE);
		if (!size)
			goto err;
		break;
	case SAS_FLASH:
		if (!active_image)
			goto err;

		if (sas_flash_layout_has_image_parts(layout)) {
			part = sas_flash_layout_image_partition(active_image - 1);
			ret = sas_boot_load_image(part, SAS_IMG_KERNEL, loadaddr);
		}
		if (sas_flash_ubi_support()) {
			if (active_image == 2)
				vol_type = SAS_UBI_KERNEL2;
			else
				vol_type = SAS_UBI_KERNEL1;

			ret = sas_ubi_volume_read(vol_type, (void *)loadaddr, 0);
		}
		if (ret)
			goto err;
		break;
	default:
		goto err;
	}

	return 0;

err:
	puts("Failed to load kernel image\n");

	return 1;
}

static int sas_servicefs_load(enum sas_flash_layout_type layout,
				int active_image, enum sas_image_src_type src)
{
	const struct sas_flash_partition *part;
	int ret;

	if (!sas_flash_layout_has_service_images(layout))
		return 0;

	if (src != SAS_FLASH)
		return 0;

	if (!active_image)
		goto err;

	part = sas_flash_layout_image_partition(active_image - 1);
	if (!part)
		goto err;

	ret = sas_boot_has_service_images(part);
	if (ret)
		return 0;

err:
	puts("Failed to load service images\n");

	return 1;
}

static int sas_mtdparts_update(enum sas_flash_layout_type layout,
				int active_image,
				enum sas_image_src_type rootfs_src,
				enum sas_image_src_type servicefs_src)
{
	int ret;

	if (sas_flash_layout_has_sysconfig_part(layout)) {
		ret = sas_boot_init_sysconfig_mtdparts(active_image, layout);
		if (ret)
			return ret;
	}

	if (sas_flash_layout_has_platform_images(layout) &&
		rootfs_src == SAS_FLASH) {
		ret = sas_boot_init_platform_mtdparts(active_image, layout);
		if (ret)
			return ret;
	}

	if (sas_flash_layout_has_service_images(layout) &&
		servicefs_src == SAS_FLASH) {
		ret = sas_boot_init_service_mtdparts(active_image, layout);
		if (ret)
			return ret;
	}

	if (sas_flash_ubi_support()) {
		ret = sas_boot_init_ubi_mtdparts(active_image, layout);
		if (ret)
			return ret;
	}

	return 0;
}

static void sas_env_fs_arg_set(const char *name, enum sas_image_src_type src)
{
	char buf[48];

	sprintf(buf, "%s=%s", name, sas_image_src_str(src));
	setenv(name, buf);
}

static void sas_env_fs_args_init(int active_image,
				enum sas_image_src_type rootfs_src,
				enum sas_image_src_type servicefs_src)
{
	sas_env_fs_arg_set("rootfs", rootfs_src);
	sas_env_fs_arg_set("servicefs", servicefs_src);
	sas_env_fs_arg_set("defconfig", servicefs_src);
}

static void sas_env_bootargs_clear(void)
{
	setenv("bootargs", NULL);
	setenv("ptest", NULL);
	setenv(sas_image_str(SAS_IMG_ROOTFS), NULL);
	setenv(sas_image_str(SAS_IMG_SERVICEFS), NULL);
	setenv(sas_image_str(SAS_IMG_DEFCONFIG), NULL);
}

static void sas_env_flashlayout_set(enum sas_flash_layout_type layout,
					int *save_env)
{
	const char flash_layout[] = "flash_layout";
	char buf[24];

	sprintf(buf, "%s=%s", flash_layout, sas_flash_layout_name(layout));
	sas_setenv(flash_layout, buf, save_env);
}

static void sas_env_compat_set(int *save_env)
{
	sas_setenv("cfg_version", "20", save_env);
	sas_setenv("uboot_name", sas_uboot_name(), save_env);
	sas_setenv("uboot_version", PLAIN_VERSION, save_env);
	sas_setenv("uboot_builddate", U_BOOT_DATE " " U_BOOT_TIME, save_env);
}

static void sas_env_base_platform_set(int *save_env)
{
	char buf[24];

	sprintf(buf, "0x%08x", sas_etl_base_platform());
	sas_setenv("base_platform", buf, save_env);
}

static void sas_env_bootargs_add(const char *value)
{
	sas_run_command("setenv bootargs $bootargs %s", value);
}

static void sas_env_bootargs_init(int ptest_mode)
{
	sas_env_bootargs_add("console=$consoledev,$baudrate");
	sas_env_bootargs_add("ip=$ipaddr:$serverip::::$netdev:off");
	sas_env_bootargs_add("ethaddr=$ethaddr");
	sas_env_bootargs_add("base_platform=$base_platform");
	sas_env_bootargs_add("$kernelcmdline $mtdparts $flash_layout");
	sas_env_bootargs_add("$rootfs $servicefs $defconfig");
	sas_env_bootargs_add("$xrx500_args");

	if (ptest_mode)
		sas_env_bootargs_add("ptest=1");

	if (sas_flash_ubi_support())
		sas_env_bootargs_add("$ubi_parts $ubi_root");
}

static void sas_env_save(int status)
{
#if 1
	if (status | getenv_ulong("sas_saveenv", 10, 0))
		sas_saveenv();
#endif
}

static int sas_bootm(ulong addr)
{
	return sas_run_command("bootm %08lx#config@0x%08x", addr,
		sas_etl_base_platform());
}

static int sas_check_ptest(enum sas_flash_layout_type flash_layout,
				enum sas_image_src_type kernel,
				enum sas_image_src_type rootfs,
				enum sas_image_src_type servicefs)
{
	const char *etl_serial_no, *ethaddr;

	/* Enable PTEST if requested by user */
	if (servicefs == SAS_PTEST)
		return 1;

	/* Auto-detect PTEST mode only if all images are booted from flash */
	if (kernel != SAS_FLASH)
		return 0;

	if (rootfs != SAS_FLASH)
		return 0;

	/* no PTEST if flash layout is not bootable */
	if (!sas_flash_layout_is_bootable(flash_layout))
		return 0;

	/* no PTEST if servicefs is not booted from flash */
	if (sas_flash_layout_has_service_images(flash_layout) &&
		servicefs != SAS_FLASH)
		return 0;

	/*
	 * No PTEST if serial number is already set or first char is
	 * different from SAS_ETL_VARIABLE_EMPTY_CHAR
	 */
	etl_serial_no = sas_etl_get_string(SAS_ETL_SERIAL);
	if (etl_serial_no && strlen(etl_serial_no))
		return 0;

	/* No PTEST if current ethaddr does not differ from default ethaddr */
	ethaddr = getenv("ethaddr");
	if (!ethaddr)
		return 0;

	if (strncmp(ethaddr, __stringify(CONFIG_ETHADDR), 17))
		return 0;

	return 1;
}

static int sas_bootlogic_active(enum sas_flash_layout_type flash_layout,
				enum sas_image_src_type kernel,
				enum sas_image_src_type rootfs,
				enum sas_image_src_type servicefs)
{
	if (kernel != SAS_FLASH)
		return 0;

	if (rootfs != SAS_FLASH)
		return 0;

	if (servicefs == SAS_PTEST)
		return 1;

	if (sas_flash_layout_has_service_images(flash_layout) &&
		servicefs == SAS_FLASH)
		return 1;

	if (sas_flash_ubi_support())
		return 1;

	return 0;
}

static int do_sas_boot(cmd_tbl_t * cmdtp, int flag, int argc, char *const argv[])
{
	const char *kernel_src, *rootfs_src, *servicefs_src;
	const enum sas_flash_layout_type flash_layout = sas_flash_layout_current();
	enum sas_image_src_type kernel, rootfs, servicefs;
	ulong loadaddr;
	int ret = 0, save_env = 0;
	int boot_logic, ptest_mode, can_boot;
	int retry, active_image;

	if (!sas_etl_version()) {
		printf("Cannot boot without Gemini typelabel\n");
		ret = 1;
		return 1;
	}

	if (argc == 4) {
		kernel_src = argv[1];
		rootfs_src = argv[2];
		servicefs_src = argv[3];
	} else if (argc == 1) {
		kernel_src = getenv("kernel_src");
		rootfs_src = getenv("rootfs_src");
		servicefs_src = getenv("servicefs_src");
	} else
		return CMD_RET_USAGE;

	kernel = sas_parse_image_src(kernel_src, SAS_FLASH);
	rootfs = sas_parse_image_src(rootfs_src, SAS_FLASH);
	servicefs = sas_parse_image_src(servicefs_src, SAS_FLASH);

	if (kernel == SAS_INVALID || rootfs == SAS_INVALID ||
		servicefs == SAS_INVALID)
		return CMD_RET_USAGE;

	ptest_mode = sas_check_ptest(flash_layout, kernel, rootfs, servicefs);

	/* Fixup servicefs mode if ptest auto-detection sets ptest_mode to 1 */
	if (ptest_mode && servicefs != SAS_PTEST) {
		servicefs = SAS_PTEST;
		if (!servicefs_src)
			sas_image_src_set("servicefs_src", servicefs, &save_env);
	}

	loadaddr = getenv_ulong("loadaddr", 16, 0);
	boot_logic = sas_bootlogic_active(flash_layout, kernel, rootfs,
						servicefs);

	printf("Booting with: kernel %s, rootfs %s, servicefs %s, boot_logic %d ptest %d\n",
		sas_image_src_str(kernel), sas_image_src_str(rootfs),
		sas_image_src_str(servicefs), boot_logic, ptest_mode);

	/* Handle persistent env variables */
	sas_env_bootargs_clear();
	sas_env_flashlayout_set(flash_layout, &save_env);
	sas_env_base_platform_set(&save_env);
	sas_env_compat_set(&save_env);

	retry = 0;
	can_boot = 1;
	do {
		/*
		 * If active_image is equal to 0 then no partition contains the
		 * complete set of boot images (kernel + different rootfs types).
		 * Otherwise the partition index in range 1..max_partitions
		 * is returned.
		 */
		active_image = sas_boot_find_working_image(flash_layout);
		/*
		 * Abort immediately if boot logic is enabled and
		 * no active images could be found.
		 */
		if (boot_logic && !active_image) {
			can_boot = 0;
			break;
		}

		/* Load kernel from flash or via TFTP */
		ret = sas_kernel_load(flash_layout, active_image, kernel,
			loadaddr);
		if (ret)
			return 1;

		ret = sas_servicefs_load(flash_layout, active_image, servicefs);
		if (ret)
			return 1;

		if (boot_logic && active_image && !ptest_mode)
			can_boot = sas_boot_update_states(active_image, &retry,
								&save_env);
	} while (retry);

	if (!can_boot) {
		puts("Invalid or incomplete images available for boot\n");
		return 1;
	}

	sas_etl_env_save(&save_env);
	sas_env_save(save_env);

	ret = sas_mtdparts_update(flash_layout, active_image, rootfs,
		servicefs);
	if (ret) {
		puts("Failed to init mtdparts\n");
		return 1;
	}

	/* Handle transient env variables */
	sas_env_fs_args_init(active_image, rootfs, servicefs);
	sas_env_bootargs_init(ptest_mode);

	/* Perform boot */
	return sas_bootm(loadaddr);
}

U_BOOT_CMD(sas_boot, 4, 1, do_sas_boot,
	"Sphairon kernel and rootfs loader",
	"[kernel_src rootfs_src servicefs_src] \n"
	"    - kernel_src = [flash|tftp]\n"
	"    - rootfs_src = [flash|tftp|nfs|none]\n"
	"    - servicefs_src = [flash|tftp|nfs|none|ptest]\n");
